import Foundation

public extension ResourceState {

    /// Returns cells according to the `state` and the given `valueToItems` closure.
    /// If no values are currently available, return nil in valueToItems to
    /// show an item generated by `noResultsItemGenerator`/`errorItemGenerator`/`loadingCellGenerator`
    /// instead.
    func addLoadingAndErrorStates<BaseItemModelType: ItemModel, SectionModelType: SectionModel>(
        valueToIdiomaticListViewStateTransformer: ValueToListViewStateTransformer
        <Value, P, E, IdiomaticItemModel<BaseItemModelType>, SectionModelType>,
        loadingSection:
        @escaping (ResourceState)
        -> SectionAndItems<IdiomaticItemModel<BaseItemModelType>, SectionModelType>,
        errorSection:
        @escaping (E)
        -> SectionAndItems<IdiomaticItemModel<BaseItemModelType>, SectionModelType>,
        noResultsSection:
        @escaping (ResourceState)
        -> SectionAndItems<IdiomaticItemModel<BaseItemModelType>, SectionModelType>
        ) -> ListViewState<Value, P, E, IdiomaticItemModel<BaseItemModelType>, SectionModelType>
        where BaseItemModelType.E == E {

            guard let loadImpulse = self.loadImpulse else {
                return ListViewState<Value, P, E, IdiomaticItemModel<BaseItemModelType>, SectionModelType>.notReady
            }

            func boxedValueToSections(_ box: EquatableBox<Value>?)
                -> [SectionAndItems<IdiomaticItemModel<BaseItemModelType>, SectionModelType>]? {

                    return (box?.value).flatMap { value
                        -> [SectionAndItems<IdiomaticItemModel<BaseItemModelType>, SectionModelType>]? in

                        return valueToIdiomaticListViewStateTransformer.valueToListViewState(
                            value,
                            self
                        ).sectionsWithItems
                    }
            }

            func numberOfItems(
                _ sections: [SectionAndItems<IdiomaticItemModel<BaseItemModelType>, SectionModelType>]
                ) -> Int {
                return sections.map({ $0.items.count }).reduce(0, +)
            }

            var noResults: ListViewState<Value, P, E, IdiomaticItemModel<BaseItemModelType>, SectionModelType> {
                return ListViewState.readyToDisplay(
                    self,
                    [noResultsSection(self)]
                )
            }

            var empty: ListViewState<Value, P, E, IdiomaticItemModel<BaseItemModelType>, SectionModelType> {
                return ListViewState.readyToDisplay(
                    self,
                    [SectionAndItems(SectionModelType(), [])]
                )
            }

            func showError(_ error: E)
                -> ListViewState<Value, P, E, IdiomaticItemModel<BaseItemModelType>, SectionModelType> {
                    return ListViewState.readyToDisplay(
                        self,
                        [errorSection(error)]
                    )
            }

            var loading: ListViewState<Value, P, E, IdiomaticItemModel<BaseItemModelType>, SectionModelType> {
                    return ListViewState.readyToDisplay(
                        self,
                        [loadingSection(self)]
                    )
            }

            switch provisioningState {
            case .notReady:
                return ListViewState<Value, P, E, IdiomaticItemModel<BaseItemModelType>, SectionModelType>.notReady
            case .loading:
                if let sections = boxedValueToSections(value), numberOfItems(sections) > 0 {
                    // Loading and there are fallback items, return them
                    return ListViewState.readyToDisplay(
                        self,
                        sections
                    )
                } else if self.error != nil {
                    // Loading, error, and there are no fallback items > return loading item
                    // if the loadImpulse permits it, or if no loadImpulse available (== .notReady)
                    if self.loadImpulse?.type.showLoadingIndicator ?? true {
                        return loading
                    } else {
                        return empty
                    }
                } else if value != nil {
                    // Loading and there is an empty fallback balue, return noResults item.
                    // We could also just display only the loadingSection instead, but then the view
                    // would e.g. jump from noResults to loading-only to noResults. While technically
                    // correct, keeping noResults is less irritating.
                    return noResults
                } else {
                    // Loading and there are no fallback items, return loading item
                    if self.loadImpulse?.type.showLoadingIndicator ?? true {
                        return loading
                    } else {
                        return empty
                    }
                }
            case .result:
                if let error = self.error {
                    return showError(error)
                } else if let value = self.value {
                    if let sections = boxedValueToSections(value), numberOfItems(sections) > 0 {
                        // Success, return items
                        return ListViewState.readyToDisplay(
                            self,
                            sections
                        )
                    } else {
                        // Success without items, return noResults
                        return noResults
                    }
                } else {
                    // No error and no value, return noResults
                    return noResults
                }
            }
    }

    /// Convenience
    func addLoadingAndErrorStates<BaseItemModelType, SectionModelType: SectionModel>(
        valueToIdiomaticListViewStateTransformer: ValueToListViewStateTransformer
        <Value, P, E, IdiomaticItemModel<BaseItemModelType>, SectionModelType>,
        noResultsText: String
        ) -> ListViewState<Value, P, E, IdiomaticItemModel<BaseItemModelType>, SectionModelType>
        where BaseItemModelType.E == E {

            return addLoadingAndErrorStates(
                valueToIdiomaticListViewStateTransformer: valueToIdiomaticListViewStateTransformer,
                loadingSection: { _ in SectionAndItems(SectionModelType(), [IdiomaticItemModel.loading]) },
                errorSection: { SectionAndItems(SectionModelType(), [IdiomaticItemModel.error($0)]) },
                noResultsSection: { _ in
                    SectionAndItems(SectionModelType(), [IdiomaticItemModel.noResults(noResultsText)])
                }
            )
    }

}
