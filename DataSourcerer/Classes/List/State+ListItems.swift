import Foundation

public extension State {

    /// Returns cells according to the `state` and the given `valueToItems` closure.
    /// If no values are currently available, return nil in valueToItems to
    /// show an item generated by `noResultsItemGenerator`/`errorItemGenerator`/`loadingCellGenerator`
    /// instead.
    func idiomaticListItems<BaseItem: ListItem, Section: ListSection>(
        valueToSections: @escaping (Value) -> ListSections<BaseItem, Section>,
        loadingSection: @escaping ((State) -> SectionWithItems<IdiomaticListItem<BaseItem>, Section>),
        errorSection: @escaping ((E) -> SectionWithItems<IdiomaticListItem<BaseItem>, Section>),
        noResultsSection: @escaping ((State) -> SectionWithItems<IdiomaticListItem<BaseItem>, Section>)
        ) -> ListSections<IdiomaticListItem<BaseItem>, Section> where BaseItem.E == E {

        func boxedValueToSections(_ box: EquatableBox<Value>?)
            -> [SectionWithItems<IdiomaticListItem<BaseItem>, Section>]? {

            return (box?.value).flatMap { value
                -> [SectionWithItems<IdiomaticListItem<BaseItem>, Section>]? in

                return valueToSections(value).sectionsWithItems?.map { sectionWithItems
                    -> SectionWithItems<IdiomaticListItem<BaseItem>, Section> in
                    let items = sectionWithItems.items.map { IdiomaticListItem.baseItem($0) }
                    return SectionWithItems(sectionWithItems.section, items)
                }
            }
        }

        func noResultsOrErrorSection() -> ListSections<IdiomaticListItem<BaseItem>, Section> {
            if let error = self.error {
                return ListSections.readyToDisplay([errorSection(error)])
            } else {
                return ListSections.readyToDisplay([noResultsSection(self)])
            }
        }

        func numberOfItems(
            _ sections: [SectionWithItems<IdiomaticListItem<BaseItem>, Section>]
        ) -> Int {
            return sections.map({ $0.items.count }).reduce(0, +)
        }

        switch provisioningState {
        case .notReady:
            return ListSections<IdiomaticListItem<BaseItem>, Section>.notReady
        case .loading:
            if let sections = boxedValueToSections(value), numberOfItems(sections) > 0 {
                // Loading and there are cached items, return them
                return ListSections.readyToDisplay(sections)
            } else if let error = self.error {
                // Loading, error, and there are empty cached items, return error item
                return ListSections.readyToDisplay([errorSection(error)])
            } else if value != nil {
                // Loading and there are empty cached items, return error or noResults item
                return noResultsOrErrorSection()
            } else {
                // Loading and there is no cached value, return loading item
                return ListSections.readyToDisplay([loadingSection(self)])
            }
        case .result:
            if let value = self.value {
                if let sections = boxedValueToSections(value), numberOfItems(sections) > 0 {
                    // Success, return items
                    return ListSections.readyToDisplay(sections)
                } else {
                    // Success without items, return error or noResults item
                    return noResultsOrErrorSection()
                }
            } else {
                // Error and no cached items, return error item (or noResults item as fallback)
                return noResultsOrErrorSection()
            }
        }
    }

    /// Convenience
    func idiomaticListItems<BaseItem, Section: ListSection>(
        valueToSections: @escaping (Value)
            -> ListSections<BaseItem, Section>,
        noResultsText: String
        ) -> ListSections<IdiomaticListItem<BaseItem>, Section>
        where BaseItem.E == E {

        return idiomaticListItems(
            valueToSections: valueToSections,
            loadingSection: { _ in SectionWithItems(Section(), [IdiomaticListItem.loading]) },
            errorSection: { SectionWithItems(Section(), [IdiomaticListItem.error($0)]) },
            noResultsSection: { _ in
                SectionWithItems(Section(), [IdiomaticListItem.noResults(noResultsText)])
            }
        )
    }

    /// Returns cells according to the `state` and the given `valueToItems` closure.
    /// If no values are currently available, return nil in valueToItems to
    /// show an item generated by `noResultsItemGenerator`/`errorItemGenerator`/`loadingCellGenerator`
    /// instead.
    func idiomaticSingleSectionListItems<BaseItem: ListItem>(
        valueToItems: @escaping (Value) -> [IdiomaticListItem<BaseItem>]?,
        loadingItem: @escaping ((State) -> IdiomaticListItem<BaseItem>),
        errorItem: @escaping ((E) -> IdiomaticListItem<BaseItem>),
        noResultsItem: @escaping ((State) -> IdiomaticListItem<BaseItem>)
        ) -> SingleSectionListItems<IdiomaticListItem<BaseItem>>
        where BaseItem.E == E {

        func boxedValueToItems(_ box: EquatableBox<Value>?)
            -> [IdiomaticListItem<BaseItem>]? {
            return (box?.value).flatMap({ valueToItems($0) })
        }

        func noResultsOrErrorItem() -> SingleSectionListItems<IdiomaticListItem<BaseItem>> {
            if let error = self.error {
                return .readyToDisplay([errorItem(error)])
            } else {
                return .readyToDisplay([noResultsItem(self)])
            }
        }

        switch provisioningState {
        case .notReady:
            return .notReady
        case .loading:
            if let items = boxedValueToItems(value), items.isEmpty == false {
                // Loading and there are cached items, return them
                return .readyToDisplay(items)
            } else if let error = self.error {
                // Loading, error, and there are empty cached items, return error item
                return .readyToDisplay([errorItem(error)])
            } else if value != nil {
                // Loading and there are empty cached items, return error or noResults item
                return noResultsOrErrorItem()
            } else {
                // Loading and there is no cached value, return loading item
                return .readyToDisplay([loadingItem(self)])
            }
        case .result:
            if let value = self.value {
                if let cells = boxedValueToItems(value), cells.isEmpty == false {
                    // Success, return items
                    return .readyToDisplay(cells)
                } else {
                    // Success without items, return error or noResults item
                    return noResultsOrErrorItem()
                }
            } else {
                // Error and no cached items, return error item (or noResults item as fallback)
                return noResultsOrErrorItem()
            }
        }
    }

    /// Convenience
    func idiomaticSingleSectionListItems<BaseItem: ListItem>(
        valueToBaseItems: @escaping (Value) -> [BaseItem]?,
        noResultsText: String
        ) -> SingleSectionListItems<IdiomaticListItem<BaseItem>>
    where BaseItem.E == E {

        return idiomaticSingleSectionListItems(
            valueToItems: { value in
                return valueToBaseItems(value)?.map {
                    IdiomaticListItem<BaseItem>.baseItem($0)
                }
            },
            loadingItem: { _ in IdiomaticListItem.loading },
            errorItem: { IdiomaticListItem.error($0) },
            noResultsItem: { _ -> IdiomaticListItem<BaseItem> in
                IdiomaticListItem<BaseItem>.noResults(noResultsText)
            }
        )
    }
}
