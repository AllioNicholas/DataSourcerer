import Foundation

public extension State {

    /// Returns cells according to the `state` and the given `valueToItems` closure.
    /// If no values are currently available, return nil in valueToItems to
    /// show an item generated by `noResultsItemGenerator`/`errorItemGenerator`/`loadingCellGenerator`
    /// instead.
    func idiomaticListItems<DatasourceItem: ListItem, Section: ListSection>(
        valueToSections: @escaping (Value) -> ListSections<DatasourceItem, Section>,
        loadingSection: @escaping ((State) -> SectionWithItems<IdiomaticListItem<DatasourceItem>, Section>),
        errorSection: @escaping ((E) -> SectionWithItems<IdiomaticListItem<DatasourceItem>, Section>),
        noResultsSection: @escaping ((State) -> SectionWithItems<IdiomaticListItem<DatasourceItem>, Section>)
        ) -> ListSections<IdiomaticListItem<DatasourceItem>, Section> where DatasourceItem.E == E {

        func boxedValueToSections(_ box: EquatableBox<Value>?)
            -> [SectionWithItems<IdiomaticListItem<DatasourceItem>, Section>]? {

            return (box?.value).flatMap { value
                -> [SectionWithItems<IdiomaticListItem<DatasourceItem>, Section>]? in

                return valueToSections(value).sectionsWithItems?.map { sectionWithItems
                    -> SectionWithItems<IdiomaticListItem<DatasourceItem>, Section> in
                    let items = sectionWithItems.items.map { IdiomaticListItem.datasourceItem($0) }
                    return SectionWithItems(sectionWithItems.section, items)
                }
            }
        }

        func noResultsOrErrorSection() -> ListSections<IdiomaticListItem<DatasourceItem>, Section> {
            if let error = self.error {
                return ListSections.readyToDisplay([errorSection(error)])
            } else {
                return ListSections.readyToDisplay([noResultsSection(self)])
            }
        }

        func numberOfItems(
            _ sections: [SectionWithItems<IdiomaticListItem<DatasourceItem>, Section>]
        ) -> Int {
            return sections.map({ $0.items.count }).reduce(0, +)
        }

        switch provisioningState {
        case .notReady:
            return ListSections<IdiomaticListItem<DatasourceItem>, Section>.notReady
        case .loading:
            if let sections = boxedValueToSections(value), numberOfItems(sections) > 0 {
                // Loading and there are cached items, return them
                return ListSections.readyToDisplay(sections)
            } else if let error = self.error {
                // Loading, error, and there are empty cached items, return error item
                return ListSections.readyToDisplay([errorSection(error)])
            } else if value != nil {
                // Loading and there are empty cached items, return error or noResults item
                return noResultsOrErrorSection()
            } else {
                // Loading and there is no cached value, return loading item
                return ListSections.readyToDisplay([loadingSection(self)])
            }
        case .result:
            if let value = self.value {
                if let sections = boxedValueToSections(value), numberOfItems(sections) > 0 {
                    // Success, return items
                    return ListSections.readyToDisplay(sections)
                } else {
                    // Success without items, return error or noResults item
                    return noResultsOrErrorSection()
                }
            } else {
                // Error and no cached items, return error item (or noResults item as fallback)
                return noResultsOrErrorSection()
            }
        }
    }

    /// Convenience
    func idiomaticListItems<DatasourceItem, Section: ListSection>(
        valueToSections: @escaping (Value)
            -> ListSections<DatasourceItem, Section>,
        noResultsText: String
        ) -> ListSections<IdiomaticListItem<DatasourceItem>, Section>
        where DatasourceItem.E == E {

        return idiomaticListItems(
            valueToSections: valueToSections,
            loadingSection: { _ in SectionWithItems(Section(), [IdiomaticListItem.loading]) },
            errorSection: { SectionWithItems(Section(), [IdiomaticListItem.error($0)]) },
            noResultsSection: { _ in
                SectionWithItems(Section(), [IdiomaticListItem.noResults(noResultsText)])
            }
        )
    }

    /// Returns cells according to the `state` and the given `valueToItems` closure.
    /// If no values are currently available, return nil in valueToItems to
    /// show an item generated by `noResultsItemGenerator`/`errorItemGenerator`/`loadingCellGenerator`
    /// instead.
    func idiomaticSingleSectionListItems<DatasourceItem: ListItem>(
        valueToItems: @escaping (Value) -> [IdiomaticListItem<DatasourceItem>]?,
        loadingItem: @escaping ((State) -> IdiomaticListItem<DatasourceItem>),
        errorItem: @escaping ((E) -> IdiomaticListItem<DatasourceItem>),
        noResultsItem: @escaping ((State) -> IdiomaticListItem<DatasourceItem>)
        ) -> SingleSectionListItems<IdiomaticListItem<DatasourceItem>>
        where DatasourceItem.E == E {

        func boxedValueToItems(_ box: EquatableBox<Value>?)
            -> [IdiomaticListItem<DatasourceItem>]? {
            return (box?.value).flatMap({ valueToItems($0) })
        }

        func noResultsOrErrorItem() -> SingleSectionListItems<IdiomaticListItem<DatasourceItem>> {
            if let error = self.error {
                return .readyToDisplay([errorItem(error)])
            } else {
                return .readyToDisplay([noResultsItem(self)])
            }
        }

        switch provisioningState {
        case .notReady:
            return .notReady
        case .loading:
            if let items = boxedValueToItems(value), items.isEmpty == false {
                // Loading and there are cached items, return them
                return .readyToDisplay(items)
            } else if let error = self.error {
                // Loading, error, and there are empty cached items, return error item
                return .readyToDisplay([errorItem(error)])
            } else if value != nil {
                // Loading and there are empty cached items, return error or noResults item
                return noResultsOrErrorItem()
            } else {
                // Loading and there is no cached value, return loading item
                return .readyToDisplay([loadingItem(self)])
            }
        case .result:
            if let value = self.value {
                if let cells = boxedValueToItems(value), cells.isEmpty == false {
                    // Success, return items
                    return .readyToDisplay(cells)
                } else {
                    // Success without items, return error or noResults item
                    return noResultsOrErrorItem()
                }
            } else {
                // Error and no cached items, return error item (or noResults item as fallback)
                return noResultsOrErrorItem()
            }
        }
    }

    /// Convenience
    func idiomaticSingleSectionListItems<DatasourceItem: ListItem>(
        valueToDatasourceItems: @escaping (Value) -> [DatasourceItem]?,
        noResultsText: String
        ) -> SingleSectionListItems<IdiomaticListItem<DatasourceItem>>
    where DatasourceItem.E == E {

        return idiomaticSingleSectionListItems(
            valueToItems: { value in
                return valueToDatasourceItems(value)?.map {
                    IdiomaticListItem<DatasourceItem>.datasourceItem($0)
                }
            },
            loadingItem: { _ in IdiomaticListItem.loading },
            errorItem: { IdiomaticListItem.error($0) },
            noResultsItem: { _ -> IdiomaticListItem<DatasourceItem> in
                IdiomaticListItem<DatasourceItem>.noResults(noResultsText)
            }
        )
    }
}
