import Foundation

public extension State {

    /// Returns cells according to the `state` and the given `valueToItems` closure.
    /// If no values are currently available, return nil in valueToItems to
    /// show an item generated by `noResultsItemGenerator`/`errorItemGenerator`/`loadingCellGenerator`
    /// instead.
    func listItems<Item: ListItem, Section: ListSection>(
        valueToSections: @escaping (Value) -> [SectionWithItems<Item, Section>]?,
        loadingSection: ((State) -> SectionWithItems<Item, Section>)?,
        errorSection: ((E) -> SectionWithItems<Item, Section>)?,
        noResultsSection: ((State) -> SectionWithItems<Item, Section>)?) -> ListSections<Item, Section> {

        func boxedValueToSections(_ box: EquatableBox<Value>?) -> [SectionWithItems<Item, Section>]? {
            return (box?.value).flatMap({ valueToSections($0) })
        }

        func noResultsOrErrorSection() -> ListSections<Item, Section> {
            if let error = self.error {
                if let errorSection = errorSection {
                    return ListSections.readyToDisplay([errorSection(error)])
                } else if let noResultsSection = noResultsSection {
                    return ListSections.readyToDisplay([noResultsSection(self)])
                } else {
                    // No errorItemGenerator set, return empty items
                    return ListSections.readyToDisplay([])
                }
            } else {
                if let noResultsSection = noResultsSection {
                    return ListSections.readyToDisplay([noResultsSection(self)])
                } else {
                    // No noResultsItemGenerator set, return empty items
                    return ListSections.readyToDisplay([])
                }
            }
        }

        func numberOfItems(_ sections: [SectionWithItems<Item, Section>]) -> Int {
            return sections.map({ $0.items.count }).reduce(0, +)
        }

        switch provisioningState {
        case .notReady:
            return ListSections<Item, Section>.notReady
        case .loading:
            if let sections = boxedValueToSections(value), numberOfItems(sections) > 0 {
                // Loading and there are cached items, return them
                return ListSections.readyToDisplay(sections)
            } else if let error = self.error, let errorSection = errorSection {
                // Loading, error, and there are empty cached items, return error item
                return ListSections.readyToDisplay([errorSection(error)])
            } else if value != nil {
                // Loading and there are empty cached items, return error or noResults item
                return noResultsOrErrorSection()
            } else {
                // Loading and there is no cached value, return loading item
                if let loadingSection = loadingSection {
                    return ListSections.readyToDisplay([loadingSection(self)])
                } else {
                    // No loadingCellGenerator set, return empty items
                    return ListSections.readyToDisplay([])
                }
            }
        case .result:
            if let value = self.value {
                if let sections = boxedValueToSections(value), numberOfItems(sections) > 0 {
                    // Success, return items
                    return ListSections.readyToDisplay(sections)
                } else {
                    // Success without items, return error or noResults item
                    return noResultsOrErrorSection()
                }
            } else {
                // Error and no cached items, return error item (or noResults item as fallback)
                return noResultsOrErrorSection()
            }
        }
    }

    /// Convenience
    func listItems<Item: IdiomaticListItem, Section: ListSection>(
        valueToSections: @escaping (Value) -> [SectionWithItems<Item, Section>]?
        ) -> ListSections<Item, Section> where Item.E == E {

        return self.listItems(
            valueToSections: valueToSections,
            loadingSection: { _ in SectionWithItems(Section(), [Item.loadingCell]) },
            errorSection: { error in SectionWithItems(Section(), [Item.errorCell(error)]) },
            noResultsSection: { _ in SectionWithItems(Section(), [Item.noResultsCell]) }
        )
    }

    /// Returns cells according to the `state` and the given `valueToItems` closure.
    /// If no values are currently available, return nil in valueToItems to
    /// show an item generated by `noResultsItemGenerator`/`errorItemGenerator`/`loadingCellGenerator`
    /// instead.
    func singleSectionListItems<Item: ListItem>(
        valueToItems: @escaping (Value) -> [Item]?,
        loadingItem: ((State) -> Item)?,
        errorItem: ((E) -> Item)?,
        noResultsItem: ((State) -> Item)?) -> SingleSectionListItems<Item> {

        func boxedValueToItems(_ box: EquatableBox<Value>?) -> [Item]? {
            return (box?.value).flatMap({ valueToItems($0) })
        }

        func noResultsOrErrorItem() -> SingleSectionListItems<Item> {
            if let error = self.error {
                if let errorItem = errorItem {
                    return SingleSectionListItems<Item>.readyToDisplay([errorItem(error)])
                } else if let noResultsItem = noResultsItem {
                    return SingleSectionListItems<Item>.readyToDisplay([noResultsItem(self)])
                } else {
                    // No errorItemGenerator set, return empty items
                    return SingleSectionListItems<Item>.readyToDisplay([])
                }
            } else {
                if let noResultsItem = noResultsItem {
                    return SingleSectionListItems<Item>.readyToDisplay([noResultsItem(self)])
                } else {
                    // No noResultsItemGenerator set, return empty items
                    return SingleSectionListItems<Item>.readyToDisplay([])
                }
            }
        }

        switch provisioningState {
        case .notReady:
            return SingleSectionListItems<Item>.notReady
        case .loading:
            if let items = boxedValueToItems(value), items.isEmpty == false {
                // Loading and there are cached items, return them
                return SingleSectionListItems<Item>.readyToDisplay(items)
            } else if let error = self.error, let errorItem = errorItem {
                // Loading, error, and there are empty cached items, return error item
                return SingleSectionListItems<Item>.readyToDisplay([errorItem(error)])
            } else if value != nil {
                // Loading and there are empty cached items, return error or noResults item
                return noResultsOrErrorItem()
            } else {
                // Loading and there is no cached value, return loading item
                if let loadingItem = loadingItem {
                    return SingleSectionListItems<Item>.readyToDisplay([loadingItem(self)])
                } else {
                    // No loadingCellGenerator set, return empty items
                    return SingleSectionListItems<Item>.readyToDisplay([])
                }
            }
        case .result:
            if let value = self.value {
                if let cells = boxedValueToItems(value), cells.isEmpty == false {
                    // Success, return items
                    return SingleSectionListItems<Item>.readyToDisplay(cells)
                } else {
                    // Success without items, return error or noResults item
                    return noResultsOrErrorItem()
                }
            } else {
                // Error and no cached items, return error item (or noResults item as fallback)
                return noResultsOrErrorItem()
            }
        }
    }

    /// Convenience
    func singleSectionListItems<Item: IdiomaticListItem>(valueToItems: @escaping (Value) -> [Item]?)
        -> SingleSectionListItems<Item> where Item.E == E {
            return self.singleSectionListItems(valueToItems: valueToItems,
                                               loadingItem: { _ in Item.loadingCell },
                                               errorItem: Item.errorCell,
                                               noResultsItem: { _ in Item.noResultsCell })
    }
}
